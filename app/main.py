from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from . import models, schemas
from .database import engine, get_db

# ENTRYPOINT NOTE
# This module (app/main.py) is the entry module for the FastAPI application.
# When you start the server with: uvicorn app.main:app
#   - 'app.main' is the Python module path to this file (the 'app' package, 'main' module).
#   - 'app' (after the colon) refers to the ASGI callable defined below: the FastAPI application instance.
# Uvicorn imports this module and serves that 'app' object.
#
# Terminology tip: In FastAPI, APIRouter is used to define route groups, and the FastAPI() instance
# is the ASGI application callable. The uvicorn target points to the application instance, not a router.
#
# Frontend analogy (React Router) and avoiding routing confusion:
# - In React Router you declare a tree of UI routes up front, mapping URL paths to components.
# - In FastAPI you declare API routes (HTTP endpoints) with decorators like @app.get("/users")
#   or by grouping them with APIRouter and including them via app.include_router(...).
#   Think of an APIRouter as a module of related endpoints (e.g., users, posts), similar to a
#   route subtree/module in React Router. Using include_router(prefix="/api/users") is analogous
#   to nesting under a parent path (like a parent Route path in React Router).


# Dev-only convenience: create tables at startup.
# Do NOT use in production â€” use migrations (e.g., Alembic) instead.
# Rationale: create_all is fine for quick demos; production needs versioned,
# auditable, incremental schema changes applied via migrations.
models.Base.metadata.create_all(bind=engine)

# FastAPI application instance (ASGI callable)
# - This 'app' object is what Uvicorn serves when you run: uvicorn app.main:app
# - 'title' and 'version' populate the autogenerated OpenAPI schema and docs
#   (visible at /docs and /redoc) and help identify your API.
# - Route decorators like @app.get/@app.post register endpoints on this instance.
# - You can also attach middleware, event handlers, and include_routers on this object.
app = FastAPI(title="FastAPI Backend", version="1.0.0")


@app.get("/")
def read_root():
    return {"message": "FastAPI Backend is running!"}


# ============================================================================
# USER CRUD OPERATIONS
# ============================================================================


@app.post("/users/")
def create_user(name: str, email: str, db: Session = Depends(get_db)):
    # Step 1: Create a Python object of class User
    # This creates an instance but doesn't save it to database yet
    # SQLAlchemy knows this will go to the 'users' table because
    # the User class has __tablename__ = "users"
    user = models.User(name=name, email=email)

    # Step 2: Add the user object to the database session
    # This stages the object for insertion but doesn't save it yet
    # SQLAlchemy looks at the object type (User) and knows to use the 'users' table
    db.add(user)

    # Step 3: Actually save the changes to the database
    # This executes the INSERT SQL statement
    # Without commit(), the user won't be saved
    db.commit()

    # Step 4: Refresh the object to get the database-generated values
    # This updates our 'user' object with the ID and created_at timestamp
    # that the database automatically generated
    db.refresh(user)

    # Step 5: Return the complete user object (now with ID and timestamps)
    return user


@app.get("/users/")
def read_users(db: Session = Depends(get_db)):
    users = db.query(models.User).all()
    return users


@app.get("/users/{user_id}")
def read_user(user_id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


# ============================================================================
# POST CRUD OPERATIONS
# ============================================================================


@app.post("/users/{user_id}/posts/", response_model=schemas.Post)
def create_post(user_id: int, post: schemas.PostCreate, db: Session = Depends(get_db)):
    # Step 1: Validate that the user exists before creating a post
    # Query the users table to find a user with the given user_id
    # .first() returns the user object if found, or None if not found
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")

    # Step 2: Create a Python object of class Post
    # **post.model_dump() unpacks the PostCreate schema into keyword arguments
    # This gives us title="..." and content="..." from the request body
    # owner_id=user_id links this post to the user from the URL parameter
    # SQLAlchemy knows this will go to the 'posts' table because
    # the Post class has __tablename__ = "posts"
    db_post = models.Post(**post.model_dump(), owner_id=user_id)

    # Step 3: Add the post object to the database session
    # This stages the object for insertion but doesn't save it yet
    # SQLAlchemy looks at the object type (Post) and knows to use the 'posts' table
    db.add(db_post)

    # Step 4: Actually save the changes to the database
    # This executes the INSERT SQL statement
    # The foreign key relationship (owner_id) gets properly linked
    db.commit()

    # Step 5: Refresh the object to get the database-generated values
    # This updates our 'db_post' object with the ID and created_at timestamp
    # that the database automatically generated
    db.refresh(db_post)

    # Step 6: Return the complete post object (now with ID and timestamps)
    # FastAPI will automatically convert this to JSON using the response_model
    return db_post


@app.get("/posts/", response_model=List[schemas.Post])
def read_posts(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    posts = db.query(models.Post).offset(skip).limit(limit).all()
    return posts


@app.get("/users/{user_id}/posts/", response_model=List[schemas.Post])
def read_user_posts(user_id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")

    posts = db.query(models.Post).filter(models.Post.owner_id == user_id).all()
    return posts


@app.get("/posts/{post_id}", response_model=schemas.Post)
def read_post(post_id: int, db: Session = Depends(get_db)):
    post = db.query(models.Post).filter(models.Post.id == post_id).first()
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post
