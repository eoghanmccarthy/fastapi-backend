# SCHEMAS MODULE NOTE
# This module (app/schemas.py) defines the Pydantic models ("schemas") used to
# validate and shape the data your API accepts (requests) and returns (responses).
# These are NOT database models â€” those live in app/models.py and describe tables.
# Instead, schemas provide:
#   - Validation: Ensure incoming data has the expected types/shapes (e.g., EmailStr).
#   - Serialization: Control the fields your API returns to clients.
#   - Documentation: FastAPI uses these to generate OpenAPI and interactive docs.
#
# Frontend analogy (Zod):
#   - If you use Zod on the frontend, think of these Pydantic models as the backend
#     counterpart: both define schemas for validation and parsing of data.
#   - Similarities: define shapes, validate at runtime, and drive typed data flows
#     (in FastAPI they also power autogenerated OpenAPI docs).
#   - Differences: Pydantic uses Python type hints and BaseModel classes; Zod is a
#     TypeScript library with schema builders and strong compile-time type inference.
#     Both validate at runtime, but their ecosystems and syntax are different.
#
# Common pattern used here:
#   - Base schemas (UserBase, PostBase) define shared fields.
#   - Create/Update schemas refine what clients send (write-models):
#       * Create: required fields for creation.
#       * Update: all fields optional to allow partial updates.
#   - Read schemas (User, Post) define what the API returns (read-models), usually
#     including DB-generated fields like id/created_at and related objects when needed.
#
# ORM compatibility:
#   - class Config: from_attributes = True enables Pydantic to read attributes from
#     SQLAlchemy ORM objects (a.k.a. "ORM mode" in Pydantic v2 terms). This allows
#     you to return ORM instances from your routes, and FastAPI will serialize them
#     according to these schemas.
#
# Relationships and nesting:
#   - The User read schema includes posts: List["Post"]. This is a forward reference
#     so the type checker understands the Post schema defined later. Be cautious when
#     adding deep or circular nesting; include only what clients actually need.
#
# Tips:
#   - Keep sensitive fields (e.g., passwords) out of read schemas.
#   - Prefer precise types (EmailStr, constr, conint) for better validation.
#   - When you change the DB models, review these schemas to ensure the API shapes
#     remain correct and stable.

from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional, List


# Base schema for users
# Other schemas will inherit from this
class UserBase(BaseModel):
    # Name is required
    name: str
    # Use EmailStr for automatic email validation
    email: EmailStr  # This validates email format automatically


# Schema for creating a user (incoming data from API request)
# This defines what fields the client must send when creating a user
class UserCreate(UserBase):
    # Inherits name and email from UserBase
    # Could add password or other create-specific fields here
    pass


# Schema for updating a user (incoming data for updates)
# All fields are optional since user might only want to update some fields
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    is_active: Optional[bool] = None


# Schema for returning user data (outgoing data from API response)
# This includes all the database fields including auto-generated ones
class User(UserBase):
    id: int
    is_active: bool
    created_at: datetime
    # Include the user's posts when returning user data
    posts: List["Post"] = []

    class Config:
        from_attributes = True


# Base schema for posts
# Other schemas will inherit from this
class PostBase(BaseModel):
    title: str
    content: str


# Schema for creating a post
# This defines what fields the client must send when creating a post
class PostCreate(PostBase):
    # Inherits title and content from PostBase
    # owner_id will be set from the URL parameter, not the request body
    pass


# Schema for updating a post
# All fields are optional since user might only want to update some fields
class PostUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None


# Schema for returning post data (outgoing data from API response)
class Post(PostBase):
    id: int
    owner_id: int
    created_at: datetime

    class Config:
        from_attributes = True
